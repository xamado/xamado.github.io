<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Projects on Xavier Amado</title><link>http://xamado.github.io/projects/</link><description>Recent content in Projects on Xavier Amado</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 07 Jul 2024 22:58:33 -0300</lastBuildDate><atom:link href="http://xamado.github.io/projects/index.xml" rel="self" type="application/rss+xml"/><item><title>Unreal 5 - Star Wars: Republic Commando Remake</title><link>http://xamado.github.io/projects/ue5-commando/</link><pubDate>Sun, 07 Jul 2024 22:58:33 -0300</pubDate><guid>http://xamado.github.io/projects/ue5-commando/</guid><description>&lt;p&gt;This is a quick prototype I did to bring back Republic Commando, a game originally developed on the Unreal 2 Engine, into modern UE5.&lt;/p&gt;
&lt;p&gt;I spent quite a long time ripping models off the original game, the fact that it shipped with a version of UnrealEd made things a bit easier to know what goes where, but ripping of meshes, textures and &amp;ldquo;shaders&amp;rdquo; (not hardware accelerated) was a bit of a handiwork, and a lot of guesswork.&lt;/p&gt;</description></item><item><title>Gameboy Color emulator</title><link>http://xamado.github.io/projects/rust-gameboy/</link><pubDate>Thu, 07 Jul 2022 22:58:33 -0300</pubDate><guid>http://xamado.github.io/projects/rust-gameboy/</guid><description>&lt;p&gt;I wrote this emulator while learning about Rust. The emulator is complete, although some games that rely on specific quirks on the original
hardware might not work perfectly.&lt;/p&gt;
&lt;p&gt;For the most part it was able to play through any of the &amp;ldquo;popular&amp;rdquo; games including the amazing audio track in Zelda&amp;rsquo;s splash screen.&lt;/p&gt;
&lt;p&gt;
 &lt;figure&gt;
 &lt;img src="gbc-zelda.png" alt="Image alt dasdasd"&gt;
 &lt;figcaption&gt;Zelda Link&amp;#39;s Awakening for GameBoy Color. Ignore de 44ms in the title, Windows snip tool freezes the rendering while taking the screenshot.&lt;/figcaption&gt;
 &lt;/figure&gt;
&lt;/p&gt;</description></item><item><title>Rust Pathtracer</title><link>http://xamado.github.io/projects/rust-pathtracer/</link><pubDate>Thu, 07 Jul 2022 22:58:33 -0300</pubDate><guid>http://xamado.github.io/projects/rust-pathtracer/</guid><description>&lt;p&gt;Another small project to have a bit more fun with Rust. It&amp;rsquo;s a very basic Path tracer.&lt;/p&gt;
&lt;p&gt;
 &lt;figure&gt;
 &lt;img src="pathtracer1.png" alt="Image alt Main"&gt;
 &lt;figcaption&gt;Basic path tracer&lt;/figcaption&gt;
 &lt;/figure&gt;
&lt;/p&gt;</description></item><item><title>Rust Quake Rasterizer</title><link>http://xamado.github.io/projects/rust-quake/</link><pubDate>Thu, 07 Jul 2022 22:58:33 -0300</pubDate><guid>http://xamado.github.io/projects/rust-quake/</guid><description>&lt;p&gt;Decided to implement a software rasterizer in Rust, and what better way to do it than using Quake 1 levels? The goal of this project wasn&amp;rsquo;t to recreate Quake 1, at least not originally, so I&amp;rsquo;m using a more standard baricentric rasterizing step, instead of a scanline approach like Quake used for performance reasons. My goal was to implement a GPU pipeline in software.&lt;/p&gt;
&lt;p&gt;Still working on this project but so far it supports:&lt;/p&gt;</description></item><item><title>Spark Game Engine</title><link>http://xamado.github.io/projects/spark/</link><pubDate>Thu, 07 Jul 2022 22:58:33 -0300</pubDate><guid>http://xamado.github.io/projects/spark/</guid><description>&lt;p&gt;Spark is a Game Engine I have been working on for&amp;hellip; ever. Started originally in 2009, but since it was always a pet/educational project I never really did anything with it, other than, well, learn! I don&amp;rsquo;t have any delusions of ever it becoming anything other than a way for me to learn and research things that interest me.&lt;/p&gt;
&lt;p&gt;Key features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some C++ 20 features. I&amp;rsquo;m not keen on using modern C++ just because it exists, but there&amp;rsquo;s a few things that I do like, like lambdas, std::function, auto for iterators and most recently std::format, which is much more clean than any string formatting ever before in C++.&lt;/li&gt;
&lt;li&gt;C++ Reflection system, allows for specifying constructors, methods and properties on objects which can be later queried and set from code, for example when parsing a scene file.&lt;/li&gt;
&lt;li&gt;Designed to be API agnostic, but currently only working on DirectX12.&lt;/li&gt;
&lt;li&gt;Embedded scripting using Mono/C#&lt;/li&gt;
&lt;li&gt;PBR renderer&lt;/li&gt;
&lt;li&gt;Dynamic Diffuse Global Illumination using Raytracing (RTX)&lt;/li&gt;
&lt;li&gt;Basic tools with scene editing, asset viewing/editing, asset browser, gizmos, etc.&lt;/li&gt;
&lt;li&gt;Texture loading from TGA, PNG, JPG or DDS files.&lt;/li&gt;
&lt;li&gt;Mesh loading from FBX files using the official FbxSDK&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
 &lt;figure&gt;
 &lt;img src="spark1.png" alt="Image alt Main"&gt;
 &lt;figcaption&gt;Main editor view&lt;/figcaption&gt;
 &lt;/figure&gt;
&lt;/p&gt;</description></item></channel></rss>